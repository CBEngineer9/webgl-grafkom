<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

</body>
<script src="three.js"></script>
<script>

    function CreateRotationAnimation( period, axis = 'x' ) {

        const times = [ 0, period ], values = [ 0, 360 ];

        const trackName = '.rotation[' + axis + ']';

        const track = new NumberKeyframeTrack( trackName, times, values );

        return new AnimationClip( null, period, [ track ] );

    }



    // scene
    const scene = new THREE.Scene();

    // camera
    const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
    camera.position.set( 0, 0, 100 );
    camera.lookAt( 0, 0, 0 );

    
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    // Cube
    // const geometry = new THREE.BoxGeometry();
    const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
    // const cube = new THREE.Mesh( geometry, material );
    // scene.add( cube );

    const points = [];
    points.push( new THREE.Vector3( - 10, 0, 0 ) );
    points.push( new THREE.Vector3( 0, 10, 0 ) );
    points.push( new THREE.Vector3( 10, 0, 0 ) );

    const geometry = new THREE.BufferGeometry().setFromPoints( points );
    const line = new THREE.Line( geometry, material );
    scene.add( line );

    // camera.position.z = 5;

    const clock = new THREE.Clock();

    // path
    const path = new THREE.Path();
    
    // path.currentPoint = 
    // path.lineTo( 0, 0.8 );
    // path.quadraticCurveTo( 0, 1, 0.2, 1 );
    // path.lineTo( 1, 1 );
    path.ellipse(0,0, 100,100, 0, 2*Math.PI, false);
    const pathPoints = path.getPoints();

    const timesArr = [];
    // const start = new THREE.Vector3(100,0,0);
    // const end = new THREE.Vector3(0,0,100);
    const valuesXArr = [];
    const valuesZArr = [];

    const valuesArr = [];

    // start.toArray(valuesArr,valuesArr.length) // print satu satu komponen ke array, dengan offset length = dibelakang
    // end.toArray(valuesArr,valuesArr.length)

    for (let i = 0; i < pathPoints.length; i++) {
        const element = pathPoints[i];
        timesArr.push(i);

        valuesXArr.push(element.x);
        valuesZArr.push(element.y);

        valuesArr.push(element.x);
        valuesArr.push(0);
        valuesArr.push(element.y);

        console.log("a");
    }

    // const posKFrame = new THREE.VectorKeyframeTrack('.position',timesArr,valuesArr, THREE.InterpolateDiscrete);
    // const posKFrame = new THREE.VectorKeyframeTrack('.position',timesArr,valuesArr, THREE.InterpolateLinear);
    const posKFrame = new THREE.NumberKeyframeTrack('.position',timesArr,valuesArr, THREE.InterpolateSmooth);
    const posXKFrame = new THREE.NumberKeyframeTrack('.position[x]',timesArr,valuesXArr, THREE.InterpolateSmooth);
    const posZKFrame = new THREE.NumberKeyframeTrack('.position[z]',timesArr,valuesZArr, THREE.InterpolateSmooth);

    const glideClip = new THREE.AnimationClip(null,timesArr[timesArr.length-1],[posKFrame]);
    const glideXClip = new THREE.AnimationClip(null,pathPoints.length,[posXKFrame]);
    const glideZClip = new THREE.AnimationClip(null,pathPoints.length,[posZKFrame]);

    const mixer = new THREE.AnimationMixer(camera);
    // const actionX = mixer.clipAction(glideXClip);
    // actionX.play();
    // const actionZ = mixer.clipAction(glideZClip);
    // actionZ.play();
    const action = mixer.clipAction(glideClip);
    action.play();

    

    function animate() {
        requestAnimationFrame( animate );

        // cube.rotation.x += 0.01;
        // cube.rotation.y += 0.01;
        mixer.update(clock.getDelta());
        camera.lookAt(0,0,0);

        renderer.render( scene, camera );
    }
    animate();
</script>
</html>